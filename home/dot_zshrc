# HELP
# - https://unix.stackexchange.com/a/487889/612293 - .zshenv, .zprofile, .zshrc,...

# REF:
# - https://github.com/mischavandenburg/dotfiles
# - https://github.com/dreamsofautonomy/zensh
# - https://github.com/Alexis12119/dotfiles
# - https://github.com/stevearc/dotfiles
# - https://github.com/omerxx/dotfiles
# - https://github.com/rusty-electron/dotfiles
# - https://github.com/chaneyzorn/dotfiles
# - https://github.com/siduck/dotfiles
# - https://github.com/craftzdog/dotfiles-public
# - https://github.com/JoosepAlviste/dotfiles
# - https://github.com/petobens/dotfiles
# - https://github.com/asilvadesigns/config


##########################################

# UPDATE PATH
typeset -aU path # Avoid recursively lengthen $path in subshell
export path=(
  $HOME/.local/share/nvim/mason/bin
  $HOME/.npm-global/bin
  $PNPM_HOME
  $HOME/.scripts
  $path
)


##########################################

# If not running interactively, don't do anything
[[ $- != *i* ]] && return


##########################################

# LIST OF PLUGINS TO USE IN OH-MY-ZSH
plugins=(
  # wakatime
  # zsh-autocomplete
  archlinux
  docker
  docker-compose
  dotenv
  extract
  fancy-ctrl-z
  fzf
  fzf-tab
  gh
  git
  sudo
  tmux
  zoxide
  zsh-256color
  zsh-autosuggestions
  zsh-syntax-highlighting

  history-substring-search # Always below zsh-syntax-highlighting
)
source $ZSH/oh-my-zsh.sh


##########################################

# UTILS

has() {
  command -v $1 >/dev/null
}

# EVALX
declare -A _EVALX_COMMANDS=(
  [clean_flatpak]='flatpak uninstall --unused'
  [clean_pacman]='sudo pacman -Scc'
  [create_python_venv]='python -m venv .venv'
  [echo_key_press]='echo $(read -k 1)'
  [get_my_ip]='curl http://ifconfig.me/ip && echo'
  [git_clean_repo]='git reflog expire --expire=now --all && git gc --prune=now --aggressive'
  [git_fetch_prune]='git fetch --prune'
  [pacman_log]='bat /var/log/pacman.log'
  [restart_kanata_service]='systemctl --user restart kanata.service'
  [source_Hyde_completion]='source Hyde.zsh'
  [source_chezmoi_completion]='source <(chezmoi completion zsh)'
  [source_npm_completion]='source <(npm completion)'
  [source_python_venv]='source .venv/bin/activate'
  [source_warp_cli_completion]='source <(warp-cli generate-completions zsh)'
  [start_docker_desktop_service]='systemctl --user start docker-desktop'
  [start_docker_service]='sudo systemctl start docker.service docker.socket'
  [start_mysql_service]='sudo systemctl start mysqld.service'
  [start_ssh_agent]='eval "$(ssh-agent -s)"'
  [stop_docker_desktop_service]='systemctl --user stop docker-desktop'
  [stop_docker_service]='sudo systemctl stop docker.service docker.socket'
  [stop_mysql_service]='sudo systemctl stop mysqld.service'
)

evalx() {
  local commands=$(printf "%s\n" "${(@k)_EVALX_COMMANDS}" | fzf --multi)
  for key in "${commands[@]}"
  do
    eval "${_EVALX_COMMANDS[$key]}"
  done
}

clean_all() {
  if has pacman; then
    printf "\nCLEAN PACMAN..."
    eval "${_EVALX_COMMANDS[clean_pacman]}"
  fi
  if has flatpak; then
    printf "\nCLEAN FLATPAK..."
    eval "${_EVALX_COMMANDS[clean_flatpak]}"
  fi
}


##########################################

# KEYBINDINGS
bindkey -e
bindkey '^p' history-substring-search-up
bindkey '^n' history-substring-search-down
bindkey '^[w' kill-region # Delete all words before cursor
bindkey '^H' backward-kill-word # Source: https://www.reddit.com/r/neovim/comments/18txgth/ctrlbackspace_doesnt_work_as_intended_in_neovim


##########################################

# ZSH CONFIG
HISTDUP=erase
HISTFILE=~/.zsh_history
HISTORY_SUBSTRING_SEARCH_PREFIXED=1
HISTSIZE=5000
SAVEHIST=$HISTSIZE
setopt APPENDHISTORY
setopt GLOBDOTS # Include hidden dir tab complete
setopt HIST_FIND_NO_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_SPACE # Ignore command start with space
setopt HIST_SAVE_NO_DUPS
setopt IGNOREEOF # Prevents <C-d> from quitting the shell
setopt PROMPT_SUBST # Enable scripting in the prompt
setopt SHAREHISTORY # Share history across shell
unsetopt BEEP # Prevents beeps in general

# Ignore command match the regex
zshaddhistory() {
  local line=${1%%$'\n'}
  [[ ! $line =~ "password|secret|private|BBb" ]]
}


##########################################

# ZSH STYLE
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'
zstyle ':completion:*' menu no
zstyle ':completion:*:descriptions' format '[%d]'
zstyle ':completion:*:git-checkout:*' sort false
zstyle ':fzf-tab:*' fzf-command ftb-tmux-popup
zstyle ':fzf-tab:*' switch-group '<' '>'
zstyle ':fzf-tab:complete:cd:*' popup-pad 30 0
zstyle ':fzf-tab:*' popup-min-size 120 10
zstyle ':fzf-tab:complete:__zoxide_z:*' fzf-preview 'eza -1 --color=always --icons=always $realpath'
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always --icons=always $realpath'
# zstyle ':autocomplete:tab:*' fzf-completion yes


##########################################

# ALIAS / FUNCTION

# Apps
if [[ -e "$HOME/.scripts/appx.sh" ]]; then
  alias ia="$HOME/.scripts/appx.sh -i"
  alias ua="$HOME/.scripts/appx.sh -u -f"
  alias uaa="$HOME/.scripts/appx.sh -U"
fi

# Ls
if has eza; then
  EZA_OPTS=(
    '--colour=always'
    '--group-directories-first'
    '--icons=auto'
    '--ignore-glob=".DS_Store|.idea|.venv|.vs|__pycache__|cache|debug|.git|node_modules|venv"'
    '-s Name'
  )
  alias l="eza -lh  $EZA_OPTS" # long list
  alias ls="exa -1 $EZA_OPTS" # Normal ls
  alias ll="exa -lag $EZA_OPTS" # Long list all
  alias ld="eza -lhD $EZA_OPTS" # long list dirs
  alias lt="eza -T $EZA_OPTS" # list folder as tree
  alias llt="eza -lagT $EZA_OPTS" # list folder as tree
else
  alias ls='ls -A --color=auto'
  alias ll='ls -lAg --color=auto'
fi

# Change directory
alias ..='cd ..'
alias ...='cd ../..'
alias .3='cd ../../..'
alias .4='cd ../../../..'
alias .5='cd ../../../../..'

# Make directory
alias mkdir='mkdir -p'

# Chezmoi
cmc() {
  { [ -n "$1" ] && chezmoi git "commit -m \"$1\"" || chezmoi git "commit"; } && chezmoi git push
}
cms() {
  chezmoi re-add
  chezmoi git "f" || { echo 'No "f" alias for git!'; cmc; }
}
alias cm='chezmoi'
alias cma='chezmoi add'
alias cme='chezmoi edit'
alias cmra='chezmoi re-add'

# Tmux
alias t='tmux'
tks() {
  if [ "$#" != "0" ]; then
    tmux kill-session -t $@
  else
    tmux kill-server
  fi
}
# ta() {
#   if [ "$#" != "0" ]; then
#     tmux attach -t $@
#   else
#     tmux has-session &>/dev/null && tmux attach || tmux
#   fi
# }

# NOTE: Src: https://dev.to/serhatteker/restore-tmux-sessions-after-reboot-7g6
ta()
{
  pgrep -vx tmux > /dev/null && \
    tmux new -d -s delete-me && \
    tmux run-shell ~/.tmux/plugins/tmux-resurrect/scripts/restore.sh && \
    tmux kill-session -t delete-me && \
    tmux attach || tmux attach
}

# ChatGPT gen it for me :(
yzcd() {
  local tmp=$(mktemp)
  yazi "$@" --cwd-file="$tmp"
  local cwd=$(<"$tmp")
  if [[ -n "$cwd" && "$cwd" != "$PWD" ]]; then
    cd "$cwd"
  fi
  rm "$tmp"
}
bindkey -s '^d' 'yzcd\n'

# Cd
alias cdc='cd ~/.config/'
alias cdcm='cd ~/.local/share/chezmoi/'
alias cdd='cd ~/Documents/'
alias cddl='cd ~/Downloads/'
alias cdg='cd ~/gits/'
alias cdnv='cd ~/.config/nvim/'

# Copy, move
if has rsync; then
  alias rcp='rsync --recursive --times --progress --stats --human-readable'
  alias rmv='rsync --recursive --times --progress --stats --human-readable --remove-source-files'
fi

# Explorer
if has dolphin; then
  function e() {
    dolphin "$@" &
  }
fi

# Others
alias c='clear'
alias cls='clear'
alias csl='clear'
alias ldk='lazydocker'
alias lg='lazygit'
alias rl='source ~/.zshrc'
alias sv='sudo -E nvim'
alias v='nvim'
alias yz='yazi'
bindkey -s '^[R' 'rl\n'


##########################################

# TMUX

# if [ -n "$TMUX" ]; then
#    enable-fzf-tab
# fi


##########################################

# FZF

_fzf_open_path() {
  local input_path=$1
  if [ ! -n "$input_path" ]; then
    return 1
  fi
  declare -A cmds=(
    [bat]='bat $input_path'
    [cat]='cat $input_path'
    [cd]='[[ -f "$input_path" ]] && input_path=$(dirname "$input_path"); cd $input_path'
    [nvim]='nvim $input_path'
    [remove]='rm -rf $input_path'
    [echo]='echo $input_path'
  )
  local cmd=$(printf "%s\n" "${(@k)cmds}" | fzf --prompt 'Select command> ')
  eval "${cmds[$cmd]}"
}

_fzf_get_path_using_fd() {
  local input_path=$(
    fd --type file |
    fzf --prompt 'Files> ' \
      --header 'CTRL-S: Switch between Files/Directories' \
      --bind 'ctrl-s:transform:[[ ! $FZF_PROMPT =~ Files ]] &&
        echo "change-prompt(Files> )+reload(fd --type file)" ||
    echo "change-prompt(Directories> )+reload(fd --type directory)"' \
      --preview '[[ $FZF_PROMPT =~ Files ]] && bat --color=always --style=plain {} || tree -C {}'
  )
  echo "$input_path"
}

_fzf_get_path_using_rg() {
  rm -f /tmp/rg-fzf-{r,f}
  local RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
  local INITIAL_QUERY="${*:-}"
  local input_path=$(
    fzf --ansi --disabled --query "$INITIAL_QUERY" \
      --bind "enter:become(echo {1})" \
      --bind "start:reload:$RG_PREFIX {q}" \
      --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true" \
      --bind 'ctrl-s:transform:[[ ! $FZF_PROMPT =~ ripgrep ]] &&
      echo "rebind(change)+change-prompt(1. ripgrep> )+disable-search+transform-query:echo \{q} > /tmp/rg-fzf-f; cat /tmp/rg-fzf-r" ||
    echo "unbind(change)+change-prompt(2. fzf> )+enable-search+transform-query:echo \{q} > /tmp/rg-fzf-r; cat /tmp/rg-fzf-f"' \
      --color "hl:-1:underline,hl+:-1:underline:reverse" \
      --prompt '1. ripgrep> ' \
      --delimiter : \
      --header 'CTRL-S: Switch between ripgrep/fzf' \
      --preview 'bat --color=always {1} --highlight-line {2} --style=plain' \
      --preview-window 'up,60%,border-bottom,+{2}+3/3'
  )
  echo "$input_path"
}

fdg() {
  _fzf_open_path "$(_fzf_get_path_using_fd)"
}

rgg() {
  _fzf_open_path "$(_fzf_get_path_using_rg)"
}

bindkey -s '^G' 'rgg\n'
bindkey -s '^F' 'fdg\n'


# NOTE: this is for ... inplace but nah. This is trash

# fdg() {
#   local output=$(__fzf_open_path "$(__fzf_get_path_using_fd)" 'true')
#   if [[ -n "$LBUFFER" ]]; then
#     LBUFFER+="${output}"
#   fi
#   local ret=$?
#   zle reset-prompt
#   return $ret
# }
# zle -N fdg
#
# rgg() {
#   local output=$(__fzf_open_path "$(__fzf_get_path_using_rg)" 'true')
#   if [[ -n "$LBUFFER" ]]; then
#     LBUFFER+="${output}"
#   fi
#   local ret=$?
#   zle reset-prompt
#   return $ret
# }
# zle -N rgg
#
# bindkey '^F' fdg
# bindkey '^G' rgg


##########################################

# BAT

alias -g -- -h='-h 2>&1 | bat --language=help --style=plain'
alias -g -- --help='--help 2>&1 | bat --language=help --style=plain'

alias bathelp='bat --plain --language=help'
help() {
  "$@" --help 2>&1 | bathelp
}


##########################################

# WIFI
# Source: https://gist.github.com/guyzmo/146423d0cf7d3c0a46e10eeb66883905

connect_wifi() {
  local ssid
  local conn

  nmcli device wifi rescan >/dev/null
  ssid=$(nmcli device wifi list | tail -n +2 | grep -v '^  *\B--\B' | fzf -m | sed 's/^ *\*//' | awk '{print $1}')

  if [ "x$ssid" != "x" ]; then
    # check if the SSID has already a connection setup
    conn=$(nmcli con | grep "$ssid" | awk '{print $1}' | uniq)
    if [ "x$conn" = "x$ssid" ]; then
      echo "Please wait while switching to known network $ssid…"
      # if yes, bring up that connection
      nmcli con up id "$conn"
    else
      echo "Please wait while connecting to new network $ssid…"
      # if not connect to it and ask for the password
      nmcli device wifi connect "$ssid"
    fi
  fi
}

get_current_wifi_password() {
  nmcli device wifi show-password
}

get_wifi_password() {
  local ssid
  ssid=$(nmcli --colors=no --fields=NAME --terse connection show |
    fzf --preview='nmcli -s -g 802-11-wireless-security.psk connection show {} || echo "Cannot get password!"'
    --preview-window='right,70%,border-left'
  )

  if [[ -z "$ssid" ]]; then
    echo "No SSID was selected!"
    return
  fi
  local password=$(nmcli -s -g 802-11-wireless-security.psk connection show $ssid)
  echo "SSID: $ssid"
  echo "PASSWORD: $password"
}


##########################################

# RUN SOME STUFF
fastfetch
eval "$(starship init zsh)"
eval "$(pyenv init -)"

# pnpm
export PNPM_HOME="/home/kevinnitro/.local/share/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
# pnpm end
